/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Type, String_$type, Delegate_$type, EnumUtil, markType } from "./type";
import { TypeDescriptionMetadata } from "./TypeDescriptionMetadata";
import { Dictionary$2 } from "./Dictionary$2";
import { List$1 } from "./List$1";
import { TypeDescriptionWellKnownType_$type } from "./TypeDescriptionWellKnownType";
import { stringReplace } from "./string";
/**
 * @hidden
 */
export let IComponentRendererAdapter_$type = /*@__PURE__*/ new Type(null, 'IComponentRendererAdapter');
/**
 * @hidden
 */
export let TypeDescriptionContext = /*@__PURE__*/ (() => {
    class TypeDescriptionContext extends Base {
        constructor(a, b) {
            super();
            this.h = new Dictionary$2(String_$type, Base.$, 0);
            this.g = new Dictionary$2(String_$type, Delegate_$type, 0);
            this.c = null;
            this.e = 0;
            this.c = a;
            this.e = b;
        }
        p(a, b) {
            this.h.item(a, b);
        }
        q(a, b) {
            this.g.item(a, b);
        }
        static o(key_) {
            if (key_ == null) {
                return null;
            }
            return key_.substr(0, 1).toUpperCase() + key_.substr(1);
        }
        static n(key_) {
            if (key_ == null) {
                return null;
            }
            return key_.substr(0, 1).toLowerCase() + key_.substr(1);
        }
        a(a) {
            if (this.h.containsKey(a)) {
                let b = this.h.item(a);
                return new List$1(String_$type, 1, b.keys).toArray();
            }
            else {
                return null;
            }
        }
        d(a, b) {
            if (this.h.containsKey(a + "@@" + b)) {
                return this.h.item(a + "@@" + b);
            }
            if (this.h.containsKey(a)) {
                let c = new TypeDescriptionMetadata();
                c.owningType = a;
                c.propertyName = b;
                let d = this.h.item(a);
                if (!d.containsKey(b)) {
                    this.h.item(a + "@@" + b, null);
                    return null;
                }
                let e = d.item(b);
                let f = "Unknown";
                let g = null;
                let h = null;
                let i = null;
                let j = e.split(')');
                if (j.length > 1) {
                    let k = j[0];
                    e = j[1];
                    k = stringReplace(k, "(", "");
                    let l = k.split(',');
                    for (let n = 0; n < l.length; n++) {
                        let m = l[n];
                        let o = m.split(':');
                        let p = o[0];
                        let q = o[1];
                        let r = 3;
                        switch (p) {
                            case "web":
                                c.m(3, q);
                                c.m(2, q);
                                c.m(4, q);
                                c.m(1, q);
                                continue;
                            case "w":
                                r = 0;
                                break;
                            case "a":
                                r = 3;
                                break;
                            case "r":
                                r = 2;
                                break;
                            case "j":
                                r = 1;
                                break;
                            case "wc":
                                r = 4;
                                break;
                            case "xf":
                                r = 5;
                                break;
                            case "xa":
                                r = 6;
                                break;
                            case "xi":
                                r = 7;
                                break;
                            case "wf":
                                r = 8;
                                break;
                        }
                        c.m(r, q);
                    }
                }
                let s = e.split(':');
                if (s.length >= 4) {
                    i = s[3];
                }
                if (s.length >= 3) {
                    g = s[2];
                }
                if (s.length >= 2) {
                    h = s[1];
                }
                if (s.length >= 1) {
                    f = s[0];
                }
                c.knownType = EnumUtil.getEnumValue(TypeDescriptionWellKnownType_$type, EnumUtil.parse(TypeDescriptionWellKnownType_$type, f, true));
                c.specificExternalType = h;
                c.specificType = g;
                c.collectionElementType = i;
                this.h.item(a + "@@" + b, c);
                return c;
            }
            return null;
        }
        l(a) {
            if (this.g.containsKey(a)) {
                return this.g.item(a)();
            }
            return null;
        }
        r(a, b, c, d) {
            if (TypeDescriptionMetadata.shouldCamelize(this.e)) {
                b = TypeDescriptionContext.n(b);
            }
            else {
                b = TypeDescriptionContext.o(b);
            }
            this.c.setPropertyValue(a, b, c, d, null, null);
        }
        s(a, b, c, d) {
            b = TypeDescriptionContext.o(b);
            this.c.setPropertyValue(a, b, c, d, null, null);
        }
        k(a) {
            return this.c.createColorCollection(a);
        }
        j(a) {
            return this.c.createBrushCollection(a);
        }
        m(a, b) {
            return this.c.createObject(a, b, this);
        }
        i(a, b) {
            return this.c.coerceToEnum(a, this, b);
        }
        b(a, b) {
            if (this.h.containsKey(a + "@@" + b + "@names")) {
                return this.h.item(a + "@@" + b + "@names");
            }
            if (this.h.containsKey(a)) {
                let c = this.h.item(a);
                if (!c.containsKey(b + "@names")) {
                    this.h.item(a + "@@" + b + "@names", null);
                    return null;
                }
                let d = c.item(b + "@names");
                let e = d.split(';');
                this.h.item(a + "@@" + b + "@names", e);
                return e;
            }
            else {
                return null;
            }
        }
        f(a, b) {
            if (this.h.containsKey(a + "@@" + b + "@nameBinding")) {
                return this.h.item(a + "@@" + b + "@nameBinding") == "true";
            }
            if (this.h.containsKey(a)) {
                let c = this.h.item(a);
                if (!c.containsKey(b + "@nameBinding")) {
                    this.h.item(a + "@@" + b + "@nameBinding", null);
                    return false;
                }
                let d = c.item(b + "@nameBinding");
                this.h.item(a + "@@" + b + "@names", d);
                return d == "true";
            }
            else {
                return false;
            }
        }
    }
    TypeDescriptionContext.$t = /*@__PURE__*/ markType(TypeDescriptionContext, 'TypeDescriptionContext');
    return TypeDescriptionContext;
})();
//# sourceMappingURL=IComponentRendererAdapter_combined.js.map
